using System;
using System.Collections.Generic;
using System.Threading;

namespace TwitchBot
{
    internal class ConfigurableMessageSender : IDisposable
    {
        public ConfigurableMessageSender(Connection connection, int messageIntervalInSeconds, List<string> configuredMessages)
        {
            _connection = connection;
            _messageIntervalInSeconds = messageIntervalInSeconds;
            _configuredMessages = configuredMessages;
            _senderThread = new Thread(new ThreadStart(SendMessageLoop));
        }

        private Connection _connection;
        private int _messageIntervalInSeconds;
        private List<string> _configuredMessages;
        private Thread _senderThread;

        private bool Run
        {
            get {
                lock(this)
                {
                    //Making the accessing + check atomic
                    return _connection != null;
                }
            }
        }
        

        private void SendMessageLoop()
        {
            // Loop and send messages until disconnected
            if (_messageIntervalInSeconds < 0 || _configuredMessages == null || _configuredMessages.Count <= 0)
            {
                return;
            }

            int messageIntervalInMillis = _messageIntervalInSeconds * 1000;
            int currentIndex = 0;
            while (Run)
            {
                string nextMessage = _configuredMessages[currentIndex];
                ++currentIndex;
                currentIndex %= _configuredMessages.Count;

                if (string.IsNullOrEmpty(nextMessage))
                {
                    continue;
                }

                // Send with lowest priority, no big deal if we're late
                lock (this)
                {
                    if (_connection != null)
                    {
                        _connection.Send(nextMessage);
                    }
                }
                Thread.Sleep(messageIntervalInMillis);
            }
        }

        public void Start()
        {
            if (!_senderThread.IsAlive)
            {
                _senderThread.Start();
            }
        }

        #region IDisposable Support
        //Generated by Visual Studio Code's "Implementing IDisposable pattern"
        private bool disposedValue = false; // To detect redundant calls

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    lock(this)
                    {
                        _connection = null;
                    }
                    //Wait for worker thread to finish loop before continuing
                    _senderThread.Join();
                    _configuredMessages = null;
                    _senderThread = null;
                }

                disposedValue = true;
            }
        }

        // This code added to correctly implement the disposable pattern.
        public void Dispose()
        {
            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
            Dispose(true);
            // TODO: uncomment the following line if the finalizer is overridden above.
            // GC.SuppressFinalize(this);
        }
        #endregion
    }
}
